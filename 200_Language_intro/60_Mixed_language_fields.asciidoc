[[mixed-lang-fields]]
=== 混合语言域

通常,那些从源数据中获得的多种语言混合在一个域中的文档会超出你的控制，
例如((("languages", "mixed language fields")))((("fields", "mixed language")))从网上爬取的页面：

[source,js]
--------------------------------------------------
{ "body": "Page not found / Seite nicht gefunden / Page non trouvée" }
--------------------------------------------------



正确的处理多语言类型文档是非常困难的。即使你简单对所有的域使用 `standard` （标准）分析器，
你的文档会变得不利于搜索，除非你使用了合适的切词为词根的分析器。但是当然，你不可能只选择一个切词为词根的分析器。
切词为词根的分析器是由语言具体决定的。或者，切词为词根的分析器是由语言和书写方式所具体决定的。像在 <<different-scripts>> 讨论中那样。
如果每个语言都使用不同的书写方式，那么切词为词根的分析器就可以合并了。


假设你的混合语言使用的是一样的书写方式，例如拉丁文，你有三个可用的选择：

* 切分到不同的域
* 进行多次分析
* 使用 n-grams

==== 切分到不同的域

The Compact Language Detector ((("languages", "mixed language fields", "splitting into separate fields")))((("Compact Language Detector (CLD)")))mentioned in <<identifying-language>> can tell
you which parts of the document are in which language.  You can split up the
text based on language and use the same approach as was used in
<<one-lang-fields>>.



==== 进行多次分析

If you primarily deal with a limited number of languages, ((("languages", "mixed language fields", "analyzing multiple times")))((("analyzers", "for mixed language fields")))((("multifields", "analying mixed language fields")))you could use
multi-fields to analyze the text once per language:

[source,js]
--------------------------------------------------
PUT /movies
{
  "mappings": {
    "title": {
      "properties": {
        "title": { <1>
          "type": "string",
          "fields": {
            "de": { <2>
              "type":     "string",
              "analyzer": "german"
            },
            "en": { <2>
              "type":     "string",
              "analyzer": "english"
            },
            "fr": { <2>
              "type":     "string",
              "analyzer": "french"
            },
            "es": { <2>
              "type":     "string",
              "analyzer": "spanish"
            }
          }
        }
      }
    }
  }
}
--------------------------------------------------
<1> The main `title` field uses the `standard` analyzer.
<2> Each subfield applies a different language analyzer
    to the text in the `title` field.

==== 使用 n-grams

You could index all words as n-grams, using the ((("n-grams", "for mixed language fields")))((("languages", "mixed language fields", "n-grams, indexing words as")))same approach as
described in <<ngrams-compound-words>>.  Most inflections involve adding a
suffix (or in some languages, a prefix) to a word, so by breaking each word into n-grams, you have a good chance of matching words that are similar
but not exactly the same. This can be combined with the _analyze-multiple
times_ approach to provide a catchall field for unsupported languages:

[source,js]
--------------------------------------------------
PUT /movies
{
  "settings": {
    "analysis": {...} <1>
  },
  "mappings": {
    "title": {
      "properties": {
        "title": {
          "type": "string",
          "fields": {
            "de": {
              "type":     "string",
              "analyzer": "german"
            },
            "en": {
              "type":     "string",
              "analyzer": "english"
            },
            "fr": {
              "type":     "string",
              "analyzer": "french"
            },
            "es": {
              "type":     "string",
              "analyzer": "spanish"
            },
            "general": { <2>
              "type":     "string",
              "analyzer": "trigrams"
            }
          }
        }
      }
    }
  }
}
--------------------------------------------------
<1> In the `analysis` section, we define the same `trigrams`
    analyzer as described in <<ngrams-compound-words>>.
<2> The `title.general` field uses the `trigrams` analyzer
    to index any language.

When querying the catchall `general` field, you can use
`minimum_should_match` to reduce the number of low-quality matches.  It may
also be necessary to boost the other fields slightly more than the `general`
field, so that matches on the main language fields are given more weight
than those on the `general` field:

[source,js]
--------------------------------------------------
GET /movies/movie/_search
{
    "query": {
        "multi_match": {
            "query":    "club de la lucha",
            "fields": [ "title*^1.5", "title.general" ], <1>
            "type":     "most_fields",
            "minimum_should_match": "75%" <2>
        }
    }
}
--------------------------------------------------
<1> All `title` or `title.*` fields are given a slight boost over the
    `title.general` field.
<2> The `minimum_should_match` parameter reduces the number of low-quality matches returned, especially important for the `title.general` field.
