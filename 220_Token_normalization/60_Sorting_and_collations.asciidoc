[[sorting-collations]]
=== 排序和整理

本章到目前为止，我们已经了解了怎么以搜索为目的去规范化词汇单元。 ((("tokens", "normalizing", "for sorting and collation"))) 本章节中要考虑的最终用例是字符串排序。 ((("sorting")))

在 <<multi-fields>> （复数域）中，我们解释了 Elasticsearch  为什么不能在 `analyzed` （分析过）的字符串字段上排序，并演示了如何为同一个域创建 _复数域索引_ ，其中 `analyzed` 域用来搜索， `not_analyzed` 域用来排序。 ((("not_analyzed fields", "for string sorting")))((("analyzed fields", "for searh")))

`analyzed` 域无法排序并不是因为使用了分析器，而是因为分析器将字符串拆分成了很多词汇单元，就像一个 _词汇袋_ ，所以 Elasticsearch 不知道使用那一个词汇单元排序。

依赖于 `not_analyzed` 域来排序的话不是很灵活：这仅仅允许我们使用原始字符串这一确定的值排序。然而我们 _可以_ 使用分析器来实现另外一种排序规则，只要你选择的分析器总是为每个字符串输出有且仅有一个的词汇单元。

[[case-insensitive-sorting]]
==== 大小写敏感排序

想象下我们有三个 `用户` 文档，文档的 `姓名` 域分别含有 `Boffey` 、((("case insensitive sorting")))((("sorting", "case insensitive"))) `BROWN` 和 `bailey` 。首先我们将使用在 <<multi-fields>> 中提到的技术，使用 `not_analyzed` 域来排序：

[source,js]
--------------------------------------------------
PUT /my_index
{
  "mappings": {
    "user": {
      "properties": {
        "name": { <1>
          "type": "string",
          "fields": {
            "raw": { <2>
              "type":  "string",
              "index": "not_analyzed"
            }
          }
        }
      }
    }
  }
}
--------------------------------------------------
<1>  `analyzed` `name` 域用来搜索。
<2>  `not_analyzed` `name.raw` 域用来排序。

我们可以索引一些文档用来测试排序：

[source,js]
--------------------------------------------------
PUT /my_index/user/1
{ "name": "Boffey" }

PUT /my_index/user/2
{ "name": "BROWN" }

PUT /my_index/user/3
{ "name": "bailey" }

GET /my_index/user/_search?sort=name.raw
--------------------------------------------------

运行这个搜索请求将会返回这样的文档排序： `BROWN` 、 `Boffey` 、 `bailey` 。 这个是 _词典排序_  ((("lexicographical order")))((("alphabetical order")))跟 _字符串排序_ 相反。基本上就是大写字母开头的字节要比小写字母开头的字节权重低，所以这些姓名是按照最低值优先排序。

这可能对计算机是合理的，但是对人来说并不是那么合理，人们更期望这些姓名按照字母顺序排序，忽略大小写。为了实现这个，我们需要把每个姓名按照我们想要的排序的顺序索引。

换句话来说，我们需要一个能输出单个小写词汇单元的分析器：

[source,js]
--------------------------------------------------
PUT /my_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "case_insensitive_sort": {
          "tokenizer": "keyword",    <1>
          "filter":  [ "lowercase" ] <2>
        }
      }
    }
  }
}
--------------------------------------------------
<1> `keyword` 分词器将输入的字符串原封不动的输出。 ((("keyword tokenizer")))
<2> `lowercase` 分词过滤器将词汇单元转化为小写字母。

使用 ((("lowercase token filter"))) `大小写不敏感排序` 分析器替换后，现在我们可以将其用在我们的复数域：

[source,js]
--------------------------------------------------
PUT /my_index/_mapping/user
{
  "properties": {
    "name": {
      "type": "string",
      "fields": {
        "lower_case_sort": { <1>
          "type":     "string",
          "analyzer": "case_insensitive_sort"
        }
      }
    }
  }
}

PUT /my_index/user/1
{ "name": "Boffey" }

PUT /my_index/user/2
{ "name": "BROWN" }

PUT /my_index/user/3
{ "name": "bailey" }

GET /my_index/user/_search?sort=name.lower_case_sort
--------------------------------------------------

<1> `name.lower_case_sort` 域将会为我们提供大小写不敏感排序。

运行这个搜索请求会得到我们想要的文档排序： `bailey` 、 `Boffey` 、 `BROWN` 。

但是这个顺序是正确的么？它符合我门的期望所以看起来像是正确的，
但我们的期望可能受到这个事实的影响：这本书是英文的，我们的例子中使用的所有字母都属于到英语字母表。

如果我们添加一个德语姓名 _Böhm_ 会怎样呢？

现在我们的姓名会返回这样的排序： `bailey` 、 `Boffey` 、 `BROWN` 、 `Böhm` 。 `Böhm` 会排在 `BROWN` 后面的原因是这些单词依然是按照它们表现的字节值排序的。 `r` 所存储的字节为 `0x72` ，而 `ö` 存储的字节值为 `0xF6` ，所以 `Böhm` 排在最后。每个字符的字节值都是历史的意外。

显然，默认排序顺序对于除简单英语之外的任何事物都是无意义的。事实上，没有完全“正确”的排序规则。这完全取决于你使用的语言。

==== 语言之间的区别

每门语言都有自己的排序规则，并且 ((("sorting", "differences between languages")))((("languages", "sort order, differences in"))) 有时候甚至有多种排序规则。 ((("Swedish, sort order")))((("German", "sort order")))((("English", "sort order"))) 这里有几个例子，我们前一小节中的四个名字在不同的上下文中是怎么排序的：

* 英语：     `bailey` 、 `boffey` 、 `böhm` 、   `brown`

* 德语：      `bailey` 、 `boffey` 、 `böhm` 、 `brown`

* 德语电话簿：  `bailey` 、 `böhm` 、 `boffey` 、 `brown`

* 瑞典语：          `bailey`, `boffey`, `brown`,  `böhm`

[NOTE]
====
德语电话簿将 `böhm` 放在 `boffey` 的原因是 `ö` 和 `oe` 在处理名字和地点的时候会被看成同义词，所以 `böhm` 在排序时像是被写成了 `boehm` 。
====

[[uca]]
==== Unicode Collation Algorithm

_Collation_ is the process of sorting text into a predefined order.((("collation")))((("Unicode Collation Algorithm (UCA)")))  The
_Unicode Collation Algorithm_, or UCA (see
http://www.unicode.org/reports/tr10/[_www.unicode.org/reports/tr10_]) defines a
method of sorting strings into the order defined in a _Collation Element
Table_ (usually referred to just as a _collation_).

The UCA also defines the _Default Unicode Collation Element Table_, or _DUCET_,
which defines the default sort order((("Default Unicode Collation Element Table (DUCET)"))) for all Unicode characters, regardless of
language. As you have already seen, there is no single correct sort order, so
DUCET is designed to annoy as few people as possible as seldom as possible,
but it is far from being a panacea for all sorting woes.

Instead, language-specific collations((("languages", "collations"))) exist for pretty much every language
under the sun. Most use DUCET as their starting point and add a few custom
rules to deal with the peculiarities of each language.

The UCA takes a string and a collation as inputs and outputs a binary sort
key. Sorting a collection of strings according to the specified collation then
becomes a simple comparison of their binary sort keys.

==== Unicode Sorting

[TIP]
=================================================

The approach described in this section will probably change in ((("Unicode", "sorting")))((("sorting", "Unicode")))a future version of
Elasticsearch. Check the <<icu-plugin,`icu` plugin>> documentation for the
latest information.

=================================================

The `icu_collation` token filter defaults((("icu_collation token filter"))) to using the DUCET
collation for sorting.  This is already an improvement over the default sort.  To use it,
all we need to do is to create an analyzer that uses the default
`icu_collation` filter:

[source,js]
--------------------------------------------------
PUT /my_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "ducet_sort": {
          "tokenizer": "keyword",
          "filter": [ "icu_collation" ] <1>
        }
      }
    }
  }
}
--------------------------------------------------
<1> Use the default DUCET collation.

Typically, the field that we want to sort on is also a field that we want to
search on, so we use the same multifield approach as we used in
<<case-insensitive-sorting>>:

[source,js]
--------------------------------------------------
PUT /my_index/_mapping/user
{
  "properties": {
    "name": {
      "type": "string",
      "fields": {
        "sort": {
          "type": "string",
          "analyzer": "ducet_sort"
        }
      }
    }
  }
}
--------------------------------------------------

With this mapping, the `name.sort` field will contain a sort key that will be
used only for sorting. ((("Default Unicode Collation Element Table (DUCET)")))((("Unicode Collation Algorithm (UCA)"))) We haven't specified a language, so it defaults to
using the <<uca,DUCET collation>>.

Now, we can reindex our example docs and test the sorting:

[source,js]
--------------------------------------------------
PUT /my_index/user/_bulk
{ "index": { "_id": 1 }}
{ "name": "Boffey" }
{ "index": { "_id": 2 }}
{ "name": "BROWN" }
{ "index": { "_id": 3 }}
{ "name": "bailey" }
{ "index": { "_id": 4 }}
{ "name": "Böhm" }

GET /my_index/user/_search?sort=name.sort
--------------------------------------------------

[NOTE]
====
Note that the `sort` key returned with each document, which in earlier
examples looked like `brown` and `böhm`, now looks like gobbledygook:
`ᖔ乏昫တ倈⠀\u0001`.  The reason is that the `icu_collation` filter emits keys
intended only for efficient sorting, not for any other purposes.
====

The preceding search returns our docs in this order: `bailey`, `Boffey`, `Böhm`,
`BROWN`. This is already an improvement, as the sort order is now correct for
English and German, but it is still incorrect for German phonebooks and
Swedish. The next step is to customize our mapping for different languages.

==== Specifying a Language

The `icu_collation` filter can be ((("icu_collation token filter", "specifying a language")))((("languages", "collation table for a specific language, icu_collation filter using")))configured to use the collation table for a
specific language, a country-specific version of a language, or some other
subset such as German phonebooks.  This can be done by creating a custom version
of the token filter by ((("German", "collation table for, icu_collation filter using")))using the `language`, `country`, and `variant` parameters
as follows:

英语::
+
[source,json]
-------------------------
{ "language": "en" }
-------------------------

德语::
+
[source,json]
-------------------------
{ "language": "de" }
-------------------------

奥地利德语::
+
[source,json]
-------------------------
{ "language": "de", "country": "AT" }
-------------------------

德语电话簿::
+
[source,json]
-------------------------
{ "language": "de", "variant": "@collation=phonebook" }
-------------------------

[TIP]
==================================================

你可以在一下网址阅读更多的 ICU 本地支持：
http://userguide.icu-project.org/locale.

==================================================

This example shows how to set up the German phonebook sort order:

[source,js]
--------------------------------------------------
PUT /my_index
{
  "settings": {
    "number_of_shards": 1,
    "analysis": {
      "filter": {
        "german_phonebook": { <1>
          "type":     "icu_collation",
          "language": "de",
          "country":  "DE",
          "variant":  "@collation=phonebook"
        }
      },
      "analyzer": {
        "german_phonebook": { <2>
          "tokenizer": "keyword",
          "filter":  [ "german_phonebook" ]
        }
      }
    }
  },
  "mappings": {
    "user": {
      "properties": {
        "name": {
          "type": "string",
          "fields": {
            "sort": { <3>
              "type":     "string",
              "analyzer": "german_phonebook"
            }
          }
        }
      }
    }
  }
}
--------------------------------------------------
<1> First we create a version of the `icu_collation` customized for the German phonebook collation.
<2> Then we wrap that up in a custom analyzer.
<3> And we apply it to our `name.sort` field.

Reindex the data and repeat the same search as we used previously:

[source,js]
--------------------------------------------------
PUT /my_index/user/_bulk
{ "index": { "_id": 1 }}
{ "name": "Boffey" }
{ "index": { "_id": 2 }}
{ "name": "BROWN" }
{ "index": { "_id": 3 }}
{ "name": "bailey" }
{ "index": { "_id": 4 }}
{ "name": "Böhm" }

GET /my_index/user/_search?sort=name.sort
--------------------------------------------------

This now returns our docs in this order: `bailey`, `Böhm`, `Boffey`,  `BROWN`.
In the German phonebook collation, `Böhm` is the equivalent of `Boehm`, which
comes before `Boffey`.

===== Multiple sort orders

The same field can support multiple ((("sorting", "multiple sort orders supported by same field")))sort orders by using a multifield for
each language:

[source,js]
--------------------------------------------------
PUT /my_index/_mapping/_user
{
  "properties": {
    "name": {
      "type": "string",
      "fields": {
        "default": {
          "type":     "string",
          "analyzer": "ducet" <1>
        },
        "french": {
          "type":     "string",
          "analyzer": "french" <1>
        },
        "german": {
          "type":     "string",
          "analyzer": "german_phonebook" <1>
        },
        "swedish": {
          "type":     "string",
          "analyzer": "swedish" <1>
        }
      }
    }
  }
}
--------------------------------------------------
<1> We would need to create the corresponding analyzers for each of these collations.

With this mapping in place, results can be ordered correctly for French,
German, and Swedish users, just by sorting on the `name.french`, `name.german`,
or `name.swedish` fields.  Unsupported languages can fall back to using the
`name.default` field, which uses the DUCET sort order.


==== Customizing Collations

The `icu_collation` token filter takes((("collation", "customizing collations")))((("icu_collation token filter", "customizing collations"))) many more options than just `language`,
`country`, and `variant`,  which can be used to tailor the sorting algorithm.
Options are available that will do the following:

* Ignore diacritics
* Order uppercase first or last, or ignore case
* Take punctuation and whitespace into account or ignore it
* Sort numbers as strings or by their numeric value
* Customize existing collations or define your own custom collations

Details of these options are beyond the scope of this book, but more information
can be found in the https://github.com/elasticsearch/elasticsearch-analysis-icu[ICU plug-in documentation]
and in the http://userguide.icu-project.org/collation/concepts[ICU project collation documentation].
